{
/*
      ___       _                _       _ _            
     |_ _|_ __ | |_ ___ _ __ ___| |_ ___| | | __ _ _ __ 
      | || '_ \| __/ _ \ '__/ __| __/ _ \ | |/ _` | '__|
      | || | | | ||  __/ |  \__ \ ||  __/ | | (_| | |   
     |___|_| |_|\__\___|_|  |___/\__\___|_|_|\__,_|_|   
                                                        
*/
// up to as of commit b96b2bb0705642db4c1458959dfaaa138f7cd0e1
/*
      ____                 
     | __ )  __ _ ___  ___ 
     |  _ \ / _` / __|/ _ \
     | |_) | (_| \__ \  __/
     |____/ \__,_|___/\___|
                           
*/
    // no base as just look at the wiki
/*
       ____            _ 
      / ___|__ _ _ __ (_)
     | |   / _` | '_ \| |
     | |__| (_| | |_) | |
      \____\__,_| .__/|_|
                |_|      
*/
    "L.api": {
        "prefix": "L.api",
        "body": "L.api()",
        "description": "Pushes the API onto the stack for access",
    },
    "L.call": {
        "prefix": "L.call",
        "body": "L.call(${1:input:number},${2:output:number})",
        "description": "Calls a function thats pushed onto the stack, (ben add more info)",
    },
    "L.pop": {
        "prefix": "L.pop",
        "body": "L.pop(${1:number})",
        "description": "Pops a value off of the stack at the top",
    },
    "L.remove": {
        "prefix": "L.remove",
        "body": "L.remove(${1:index:number})",
        "description": "Removes a value at an index off of the stack",
    },
    "L.length": {
        "prefix": "L.length",
        "body": "L.length(${1:index:number})",
        "description": "Get the length of a value",
    },
    "L.next": {
        "prefix": "L.next",
        "body": "L.next(${1:index:number})",
        "description": "A pair-style iterator function for going through table, used like pairs",
    },
    "L.pushtransfer": {
        "prefix": "L.pushtransfer",
        "body": "L.pushtransfer(${1:value})",
        "description": "Transfers any datatype from your environment to the stack, environment to stack",
    },
    "L.gettransfer": {
        "prefix": "L.gettransfer",
        "body": "L.gettransfer(${1:index:number})",
        "description": "Transfers any datatype from the stack to your environment, stack to environment",
    },
    "L.gettop": {
        "prefix": "L.gettop",
        "body": "L.gettop()",
        "description": "Gets the current size of the Lua stack",
    },
    "L.gettype": {
        "prefix": "L.gettype",
        "body": "L.gettype(${1:index:number})",
        "description": "Gets the type ID of a given value",
    },
    "L.gettypename": {
        "prefix": "L.gettypename",
        "body": "L.gettypename(${1:index:number})",
        "description": "Gets the typename of a given value",
    },
    "L.newtable": {
        "prefix": "L.newtable",
        "body": "L.newtable()",
        "description": "Generates a blank table and pushes it onto the stack",
    },
    "L.newref": {
        "prefix": "L.newref",
        "body": "L.newref(${1:index:number})",
        "description": "Creates a reference link to a value, immune to the garbage collector",
    },
    "L.pushref": {
        "prefix": "L.pushref",
        "body": "L.pushref(${1:reference})",
        "description": "Pushes the referenced value back onto the stack",
    },
    "L.rmref": {
        "prefix": "L.rmref",
        "body": "L.rmref(${1:reference})",
        "description": "Removes the referenced value from registry",
    },
    "L.getupvalue": {
        "prefix": "L.getupvalue",
        "body": "L.getupvalue(${1:index:number}, ${2:id:number})",
        "description": "Gets the \"upvalue\" of a function at the top of the stack",
    },
    "L.setupvalue": {
        "prefix": "L.setgupvalue",
        "body": "L.setupvalue(${1:index:number}, ${2:id:number})",
        "description": "Sets the \"upvalue\" of a function at the top of the stack",
    },
    "L.getfenv": {
        "prefix": "L.getfenv",
        "body": "L.getfenv(${1:index:number})",
        "description": "Grabs the ENV and pushes it onto the stack, can use this to manipulate the environment",
    },
    "L.setfenv": {
        "prefix": "L.setfenv",
        "body": "L.setfenv(${1:index:number})",
        "description": "Sets the ENV of a functions at the index, consumes the table at the top of the stack, can use this to manipulate the environment",
    },
    "L.getmetatable": {
        "prefix": "L.getmetatable",
        "body": "L.getmetatable(${1:index:number})",
        "description": "Grabs the metatable of a table or userdata, and pushes it onto the stack",
    },
    "L.setmetatable": {
        "prefix": "L.setmetatable",
        "body": "L.setmetatable(${1:index:number})",
        "description": "Sets the metatable of a table or userdata at the index, consumes the table at the top of the stack",
    },
    "L.getfield": {
        "prefix": "L.getfield",
        "body": "L.getfield(${1:index:number}, \"${2:key:string}\")",
        "description": "Gets the value from a table and pushes it onto the stack",
    },
    "L.setfield": {
        "prefix": "L.setfield",
        "body": "L.setfield(${1:index:number}, \"${2:key:string}\")",
        "description": "Sets a value in a table by key, index corresponds to where the table is on the stack",
    },
    "L.gettable": {
        "prefix": "L.gettable",
        "body": "L.gettable(${1:index:number})",
        "description": "Gets the value from a table and pushes it onto the stack",
    },
    "L.settable": {
        "prefix": "L.settable",
        "body": "L.settable(${1:index:number})",
        "description": "Sets a value in a table by the key at the top of the stack",
    },
    "L.rawget": {
        "prefix": "L.rawget",
        "body": "L.rawget(${1:index:number})",
        "description": "Gets the value from a table and pushes it onto the stack",
    },
    "L.rawset": {
        "prefix": "L.rawset",
        "body": "L.rawset(${1:index:number})",
        "description": "Sets a value in a table by the key at the top of the stack, the top of the stack is the key, and top-1 is the value, unlike settable this will not invoke metatable callbacks",
    },
    "L.getboolean": {
        "prefix": "L.getboolean",
        "body": "L.getboolean(${1:index:number})",
        "description": "Attempts to get a boolean value from the Lua stack",
    },
    "L.getnumber": {
        "prefix": "L.getnumber",
        "body": "L.getnumber(${1:index:number})",
        "description": "Attempts to get a number value from the Lua stack",
    },
    "L.getstring": {
        "prefix": "L.getstring",
        "body": "L.getstring(${1:index:number})",
        "description": "Attempts to get a string value from the Lua stack",
    },
    "L.pushnil": {
        "prefix": "L.pushnil",
        "body": "L.pushnil()",
        "description": "Pushes a nil value onto the stack",
    },
    "L.pushnumber": {
        "prefix": "L.pushnumber",
        "body": "L.pushnumber(${1:number})",
        "description": "Pushes a number onto the stack",
    },
    "L.pushstring": {
        "prefix": "L.pushstring",
        "body": "L.pushstring(\"${1:string}\")",
        "description": "Pushes a string onto the stack",
    },
    "L.pushvalue": {
        "prefix": "L.pushvalue",
        "body": "L.pushvalue(${1:index:number})",
        "description": "Makes a copy of a value at the index and pushes it to the top of the stack",
    },
    "L.pushboolean": {
        "prefix": "L.pushboolean",
        "body": "L.pushboolean(${1:boolean})",
        "description": "Pushes a boolean onto the stack",
    },
    "L.isboolean": {
        "prefix": "L.isboolean",
        "body": "L.isboolean(${1:index:number})",
    },
    "L.iscfunction": {
        "prefix": "L.iscfunction",
        "body": "L.iscfunction(${1:index:number})",
    },
    "L.isfunction": {
        "prefix": "L.isfunction",
        "body": "L.isfunction(${1:index:number})",
    },
    "L.islightuserdata": {
        "prefix": "L.islightuserdata",
        "body": "L.islightuserdata(${1:index:number})",
    },
    "L.isnil": {
        "prefix": "L.isnil",
        "body": "L.isnil(${1:index:number})",
    },
    "L.isnumber": {
        "prefix": "L.isnumber",
        "body": "L.isnumber(${1:index:number})",
    },
    "L.isstring": {
        "prefix": "L.isstring",
        "body": "L.isstring(${1:index:number})",
    },
    "L.istable": {
        "prefix": "L.istable",
        "body": "L.istable(${1:index:number})",
    },
    "L.isthread": {
        "prefix": "L.isthread",
        "body": "L.isthread(${1:index:number})",
    },
    "L.isuserdata": {
        "prefix": "L.isuserdata",
        "body": "L.isuserdata(${1:index:number})",
    },
    "L.istype": {
        "prefix": "L.istype",
        "body": "L.istype(${1:index:number})",
    },
/*
       ____                      _   _            
      / ___|___  _ __ ___  _   _| |_(_)_ __   ___ 
     | |   / _ \| '__/ _ \| | | | __| | '_ \ / _ \
     | |__| (_) | | | (_) | |_| | |_| | | | |  __/
      \____\___/|_|  \___/ \__,_|\__|_|_| |_|\___|
                                                  
*/
    // no base as just look at the wiki
/*
      ____       _                 
     |  _ \  ___| |__  _   _  __ _ 
     | | | |/ _ \ '_ \| | | |/ _` |
     | |_| |  __/ |_) | |_| | (_| |
     |____/ \___|_.__/ \__,_|\__, |
                             |___/ 
*/
    // no debug funcs as just look at the wiki
    "debug.detour": {
        "prefix": "debug.detour",
        "body": "debug.detour(${1:target}, ${2:detour})",
        "description": "Creates a memory-based hook towards a target lua function or C function",
    },
    "debug.isdetour": {
        "prefix": "debug.isdetour",
        "body": "debug.isdetour(${1:target})",
    },
    "debug.original": {
        "prefix": "debug.original",
        "body": "debug.original(${1:target})",
        "description": "If a function has a memory-mapping, this will return the original",
    },
    "debug.restore": {
        "prefix": "debug.restore",
        "body": "debug.restore(${1:target})",
        "description": "Restores the memory-mapped function",
    },
    "debug.clone": {
        "prefix": "debug.clone",
        "body": "debug.clone(${1:value})",
        "description": "Copys a value in memory, creating a completely new value but with the same characteristics",
    },
    "debug.replace": {
        "prefix": "debug.replace",
        "body": "debug.replace(${1:value}, ${2:value})",
        "description": "Replaces a value by reference in memory, effectively replacing all occurences of it.",
    },
    "debug.newcclosure": {
        "prefix": "debug.newcclosure",
        "body": "debug.newcclosure(${1:function})",
        "description": "Creates a new cfunction closure which is untraceable",
    },
    "debug.getgc": {
        "prefix": "debug.getgc",
        "body": "debug.getgc()",
        "description": "Gets the garbage collector table",
    },
    "debug.topointer": {
        "prefix": "debug.topointer",
        "body": "debug.topointer(${1:data}, ${2|true,false|})",
        "description": "Converts a datatype into it's absolute pointer location",
    },
    "debug.frompointer": {
        "prefix": "debug.frompointer",
        "body": "debug.frompointer(${1:ptr:number})",
        "description": "Scans memory to find the pointer association",
    },
    "debug.setbuiltin": {
        "prefix": "debug.setbuiltin",
        "body": "debug.setbuiltin(${1:cfunction}, ${2:ffid:number})",
        "description": "Changes a cfunction to be a Fast Function with an ID, use newcclosure if you plan to make a detour with this",
    },
    "debug.getbuiltin": {
        "prefix": "debug.getbuiltin",
        "body": "debug.getbuiltin(${1:cfunction})",
        "description": "Gets the ffid number of a cfunction",
    },
    "debug.getupvalues": {
        "prefix": "debug.getupvalues",
        "body": "debug.getupvalues(${1:function})",
        "description": "Gets a list of upvalues and that a function has",
    },
    "debug.typestack": {
        "prefix": "debug.typestack",
        "body": "debug.typestack(${1:number})",
        "description": "Fetches a list of the current stack memory",
    },
    "debug.getstack": {
        "prefix": "debug.getstack",
        "body": "debug.getstack(${1:index:number})",
        "description": "Fetchs directly from the lua stack",
    },
    "debug.setstack": {
        "prefix": "debug.setstack",
        "body": "debug.setstack(${1:index:number}, ${2:data})",
        "description": "Sets a value at an index in stack memory, this is dangerous",
    },
/*
      _____    
     |  ___|__ 
     | |_ / __|
     |  _|\__ \
     |_|  |___/
               
*/
    "fs.read": {
        "prefix": "fs.read",
        "body": "fs.read(\"${1:path}\")",
        "description": "Reads a file from a given path",
    },
    "fs.write": {
        "prefix": "fs.write",
        "body": "fs.write(\"${1:path}\", \"${2:data}\")",
        "description": "Writes to a file provided by the path",
    },
    "fs.isfile": {
        "prefix": "fs.isfile",
        "body": "fs.isfile(\"${1:path}\")",
        "description": "Checks if a filesystem object is a file",
    },
    "fs.isfolder": {
        "prefix": "fs.isfolder",
        "body": "fs.isfolder(\"${1:path}\")",
        "description": "Checks if a filesystem object is a folder",
    },
    "fs.listfiles": {
        "prefix": "fs.listfiles",
        "body": "fs.listfiles(\"${1:path}\")",
        "description": "Lists files in the specified path",
    },
    "fs.makefolder": {
        "prefix": "fs.makefolder",
        "body": "fs.makefolder(\"${1:path}\")",
        "description": "Creates a folder in the specified path",
    },
    "fs.delfolder": {
        "prefix": "fs.delfolder",
        "body": "fs.delfolder(\"${1:path}\")",
        "description": "Deletes a folder from the specified path",
    },
    "fs.delfile": {
        "prefix": "fs.delfile",
        "body": "fs.delfile(\"${1:path}\")",
        "description": "Deletes a file from the specified path",
    },
    "fs.append": {
        "prefix": "fs.append",
        "body": "fs.append(\"${1:path}\", \"${2:data}\")",
        "description": "Appends data onto the specified file",
    },
    "fs.forward": {
        "prefix": "fs.forward",
        "body": "fs.forward(\"${1:path}\")",
        "description": "Changes all \"\\\" separators to \"/\"",
    },
    "fs.backward": {
        "prefix": "fs.backward",
        "body": "fs.backward(\"${1:path}\")",
        "description": "Changes all \"/\" separators to \"\\\"",
    },
    "fs.join": {
        "prefix": "fs.backward",
        "body": "fs.backward(\"${1:path}\", \"${2:path}\")",
        "description": "Joins two paths together",
    },
/*
      ____       __ _           _   _             
     |  _ \ ___ / _| | ___  ___| |_(_) ___  _ __  
     | |_) / _ \ |_| |/ _ \/ __| __| |/ _ \| '_ \ 
     |  _ <  __/  _| |  __/ (__| |_| | (_) | | | |
     |_| \_\___|_| |_|\___|\___|\__|_|\___/|_| |_|
                                                  
*/
    "reflection.is": {
        "prefix": "reflection.is",
        "body": "reflection.is(\"${1:name}\")",
        "description": "Checks if the current execution is of a named",
    },
    "reflection.get": {
        "prefix": "reflection.get",
        "body": "reflection.get(\"${1:name}\")",
        "description": "Attempts to locate a lua_State",
    },
    "reflection.current": {
        "prefix": "reflection.current",
        "body": "reflection.current()",
        "description": "Gets the current lua_State this is executed in",
    },
    "reflection.all": {
        "prefix": "reflection.all",
        "body": "reflection.all()",
        "description": "Gets all instances of lua_State and their names",
    },
    "reflection.name": {
        "prefix": "reflection.name",
        "body": "reflection.name(${1:state})",
        "description": "Converts a lua_State to its named counterpart",
    },
    "reflection.execute": {
        "prefix": "reflection.execute",
        "body": "reflection.execute([[\n\t${1:source}\n]], \"${2:name}\", ${3:state})",
        "description": "Converts a lua_State to its named counterpart",
    },
    "reflection.compile": {
        "prefix": "reflection.compile",
        "body": "reflection.compile(\"${1:source}\", \"${2:name}\")",
        "description": "Compiles lua on the the current active state its in",
    },
    "reflection.replicate": {
        "prefix": "reflection.replicate",
        "body": "reflection.replicate(${1:function}, ${2:state})",
        "description": "Transfers a function to run on another lua_State, no upvalues must be present",
    },
    "reflection.open": {
        "prefix": "reflection.open",
        "body": "reflection.open(\"${1:name}\")",
        "description": "Spawns a new lua_State instance or returns one if it already exists",
    },
    "reflection.close": {
        "prefix": "reflection.close",
        "body": "reflection.close(${1:state})",
        "description": "Destroys a lua_State instance",
    },
    "reflection.stack": {
        "prefix": "reflection.stack",
        "body": "reflection.stack(${1:function(${2:lua_capi})}\n\nend, ${3:state})",
        "description": "Creates a temporary bridge between two lua states",
    },
/*
      ____  _                   _ 
     / ___|(_) __ _ _ __   __ _| |
     \___ \| |/ _` | '_ \ / _` | |
      ___) | | (_| | | | | (_| | |
     |____/|_|\__, |_| |_|\__,_|_|
              |___/               
*/
	"signal.add": {
        "prefix": "signal.add",
        "body": "signal.add(\"${1:name}\", \"${2:indentity}\", function()\n\nend)",
        "description": "Adds a function to an signal, this will call the callback when C++ invokes it",
    },
	"signal.remove": {
        "prefix": "signal.remove",
        "body": "signal.remove(\"${1:name}\", \"${2:indentity}\")",
        "description": "Removes a function from a signal",
    },
	"signal.get": {
        "prefix": "signal.get",
        "body": "signal.get(\"${1:name}\", \"${2:indentity}\")",
        "description": "Attempts to retrieve a function from the signal callbacks",
    },
	"signal.call": {
        "prefix": "signal.call",
        "body": "signal.call(${1:state}, \"${2:name}\")",
        "description": "Calls events on a lua_State, Must have the same matching name",
    },
	"signal.connect": {
        "prefix": "signal.connect",
        "body": "signal.connect(\"${1:name}\", \"${2:identity}\" function()\n\nend)",
        "description": "Same as signal.add, RBLX standard",
    },
	"signal.disconnect": {
        "prefix": "signal.disconnect",
        "body": "signal.disconnect(\"${1:name}\", \"${2:identity}\")",
        "description": "Same as signal.remove, RBLX standard",
    },
	"signal.connection": {
        "prefix": "signal.connection",
        "body": "signal.connection(\"${1:name}\", \"${2:identity}\")",
        "description": "Same as signal.get, RBLX standard",
    },
	"signal.fire": {
        "prefix": "signal.fire",
        "body": "signal.fire(${1:state}, \"${2:name}\")",
        "description": "Same as signal.call, RBLX standard",
    },
/*
      ___      _   
     |_ _|___ | |_ 
      | |/ _ \| __|
      | | (_) | |_ 
     |___\___/ \__|
                   
*/
    "iot.http": {
        "prefix": "iot.http",
        "body": "iot.http(\"${1:url}\", function(${2:response}) ${3:options})\n\nend)", // i think the )) is a error but whatever
        "description": "CHECK THE WIKI, Makes an HTTP/HTTPS request to an address or domain",
    },
    "iot.socket": {
        "prefix": "iot.socket",
        "body": "iot.socket(\"${1:url}\", ${2:options})", // will need to add the options later to both iot
        "description": "CHECK THE WIKI, Creates a socket object which is connected to an address or domain, the socket isn't activated until you invoke it to do so",
    },
    // others just check the wiki
    // no os or math, CHECK THE WIKI!!!!!!
/*
      ____       _       _   
     |  _ \ __ _(_)_ __ | |_ 
     | |_) / _` | | '_ \| __|
     |  __/ (_| | | | | | |_ 
     |_|   \__,_|_|_| |_|\__|
                             
*/
    "paint.point.vector2": {
        "prefix": "paint.point.vector2",
        "body": "paint.point.vector2(${1:x}, ${2:y})",
        "description": "Creates a 2D vector for paint to recognize",
    },
    "paint.point.vector3": {
        "prefix": "paint.point.vector3", // add shortcuts to paint
        "body": "paint.point.vector3(${1:x}, ${2:y})",
        "description": "Creates a 3D vector for paint to recognize",
    },
    "paint.color.rgb": {
        "prefix": "paint.color.rgb",
        "body": "paint.color.rgb(${1:r}, ${2:g}, ${3:b})",
        "description": "Creates an RGB based color",
    },
    "paint.color.rgba": {
        "prefix": "paint.color.rgba",
        "body": "paint.color.rgba(${1:r}, ${2:g}, ${3:b}, ${4:a})",
        "description": "Creates an RGBA based color",
    },
    "paint.color.hex": {
        "prefix": "paint.color.hex",
        "body": "paint.color.hex(\"${1:hex code}\")",
        "description": "Creates an RGBA based color from hex",
    },
    "paint.color.hsv": {
        "prefix": "paint.color.hsv",
        "body": "paint.color.hsv(${1:h}, ${2:s}, ${3:v}, ${4:a})",
        "description": "Creates an RGBA based color from HSV",
    },
    "paint.color.hsl": {
        "prefix": "paint.color.hsl",
        "body": "paint.color.hsl(${1:h}, ${2:s}, ${3:L}, ${4:a})",
        "description": "Creates an RGBA based color from HSL",
    },
    "paint.line": {
        "prefix": "paint.line",
        "body": "paint.line(${1:p1}, ${2:p2}, ${3:paint_color}, ${4:thickness}, ${5:paint_color}, ${6:outline_thickness})",
        "description": "Creates a line between points A and B"
    },
    "paint.circle.filled": {
        "prefix": "paint.circle.filled",
        "body": "paint.circle.filled(${1:center_point}, ${2:paint_color}, ${3:radius}, ${4:paint_color}, ${5:outline_thickness})",
        "description": "Creates a filled circle around a center point"
    },
    "paint.circle.hollow": {
        "prefix": "paint.circle.hollow",
        "body": "paint.circle.hollow(${1:center_point}, ${2:paint_color}, ${3:radius}, ${4:thickness}, ${5:paint_color}, ${6:outline_thickness})",
        "description": "Creates a hollow circle around a center point"
    },
    "paint.tri.filled": {
        "prefix": "paint.tri.filled",
        "body": "paint.tri.filled(${1:p1}, ${2:p2}, ${3:p3}, ${4:paint_color}, ${5:paint_color}, ${6:outline_thickness})",
        "description": "Creates a filled triangle from three points"
    },
    "paint.tri.hollow": {
        "prefix": "paint.tri.hollow",
        "body": "paint.tri.hollow(${1:p1}, ${2:p2}, ${3:p3}, ${4:paint_color}, ${5:thickness}, ${6:paint_color}, ${7:outline_thickness})",
        "description": "Creates a hollow triangle from three points"
    },
    "paint.rect.filled": {
        "prefix": "paint.rect.filled",
        "body": "paint.rect.filled(${1:top_left_point}, ${2:size}, ${3:paint_color}, ${4:paint_color}, ${5:outline_thickness})",
        "description": "Creates a filled rectangle"
    },
    "paint.rect.hollow": {
        "prefix": "paint.rect.hollow",
        "body": "paint.rect.hollow(${1:top_left_point}, ${2:size}, ${3:paint_color}, ${4:thickness}, ${5:paint_color}, ${6:outline_thickness})",
        "description": "Creates a hollow rectangle"
    },
    "paint.rect.gradient": {
        "prefix": "paint.rect.gradient",
        "body": "paint.rect.gradient(${1:top_left_point}, ${2:size}, ${3:paint_color}, ${4:paint_color}, ${5:paint_color}, ${6:paint_color}, ${7:paint_color}, ${8:outline_thickness})",
        "description": "Creates a rectangle using a gradient of colors"
    },
    "paint.quad.filled": {
        "prefix": "paint.quad.filled",
        "body": "paint.quad.filled(${1:p1}, ${2:p2}, ${3:p3}, ${4:p4}, ${5:paint_color}, ${6:paint_color}, ${7:outline_thickness})",
        "description": "Creates a filled quadrilateral"
    },
    "paint.quad.hollow": {
        "prefix": "paint.quad.hollow",
        "body": "paint.quad.hollow(${1:p1}, ${2:p2}, ${3:p3}, ${4:p4}, ${5:paint_color}, ${6:thickness}, ${7:paint_color}, ${8:outline_thickness})",
        "description": "Creates a hollow quadrilateral"
    },
    "paint.text.left": {
        "prefix": "paint.text.left",
        "body": "paint.text.left(${1:point}, \"${2:text}\", ${3:paint_color}, ${4:paint_color}, ${5:outline_thickness})",
        "description": "Creates left-aligned text"
    },
    "paint.text.center": {
        "prefix": "paint.text.center",
        "body": "paint.text.center(${1:point}, \"${2:text}\", ${3:paint_color}, ${4:paint_color}, ${5:outline_thickness})",
        "description": "Creates center-aligned text"
    },
    "paint.text.right": {
        "prefix": "paint.text.right",
        "body": "paint.text.right(${1:point}, \"${2:text}\", ${3:paint_color}, ${4:paint_color}, ${5:outline_thickness})",
        "description": "Creates right-aligned text"
    },
    "paint.image.normal": {
        "prefix": "paint.image.normal",
        "body": "paint.image.normal(${1:image}, ${2:top_left_point}, ${3:size}, ${4:paint_color}, ${5:paint_color}, ${6:outline_thickness})",
        "description": "Creates a rectangle image"
    },
    "paint.image.round": {
        "prefix": "paint.image.round",
        "body": "paint.image.round(${1:image}, ${2:rounding}, ${3:top_left_point}, ${4:size}, ${5:paint_color}, ${6:paint_color}, ${7:outline_thickness})",
        "description": "Creates a rectangle image with rounding"
    },
    "paint.text.bake": {
        "prefix": "paint.text.bake",
        "body": "paint.text.bake(\"${1:font_name}\", ${2:font_data}, ${3:size})",
        "description": "Bakes a font into memory for rendering"
    },
    "paint.text.unbake": {
        "prefix": "paint.text.unbake",
        "body": "paint.text.unbake(\"${1:font_name}\")",
        "description": "Unloads a baked font from memory"
    },
    "paint.text.isbaked": {
        "prefix": "paint.text.isbaked",
        "body": "paint.text.isbaked(\"${1:font_name}\")",
        "description": "Returns true if font is currently baked"
    },
    "paint.text.font": {
        "prefix": "paint.text.font",
        "body": "paint.text.font(\"${1:font_name}\")",
        "description": "Sets/gets the current paint text font"
    },
    "paint.add": {
        "prefix": "paint.add",
        "body": "paint.add(\"${1:identity}\", function(${2:args})\n\t${3:}\nend)",
        "description": "Creates right-aligned text"
    },
    // NO TABLE LOOK AT THE WIKIIIII
/*
       ____                       _       __  __           _ 
      / ___| __ _ _ __ _ __ _   _( )___  |  \/  | ___   __| |
     | |  _ / _` | '__| '__| | | |// __| | |\/| |/ _ \ / _` |
     | |_| | (_| | |  | |  | |_| | \__ \ | |  | | (_) | (_| |
      \____|\__,_|_|  |_|   \__, | |___/ |_|  |_|\___/ \__,_|
                            |___/                            
*/
/*
      _     _       _             
     | |   (_)_ __ | | _____ _ __ 
     | |   | | '_ \| |/ / _ \ '__| (fix this so its alined idk if it will look good but who knows)
     | |___| | | | |   <  __/ |   
     |_____|_|_| |_|_|\_\___|_|   
                                  
*/
// this whole section needs a rework
    "linker": {
        "prefix": "secret.linker",
        "body": "secret.linker", // need more info later
        "description": "Look at the secretserivce wiki and Garry's Mod official wiki for more information, Can be used just as net, nw, nvar, hook, etc, for hooks Metatables from userdata values such as CUserCmd do not transfer",
    },
    "linker.meta": {
        "prefix": "secret.linker.meta",
        "body": "secret.linker.meta(\"${1:library}\", \"${2:name}\")",
        "description": "Fetches a metatable class function, like \"Player.GetEyeAngles\"",
    },
    "linker.global": {
        "prefix": "secret.linker.global",
        "body": "secret.linker.global(\"${1:library}\", \"${2:name}\")",
        "description": "Fetches a global class function, like \"surface.CreateFont\"",
    },
    "linker.isolate": {
        "prefix": "secret.linker.isolate",
        "body": "secret.linker.isolate(${1|true,false|})", // now that i realized i need to fix all the boolean placeholders
        "description": "Creates an abolute isolated states, where _G and the ENV will only access linker libraries",
    },
/*
      _   _ ___ 
     | | | |_ _|
     | | | || | 
     | |_| || | 
      \___/|___|
                
*/
    "create_playerlist_button": {
        "prefix": "secret.create_playerlist_button",
        "body": "secret.create_playerlist_button(\"${1:name}\", ${2:entity index}, ${3:callback})",
        "description": "Creates a button UI element in the 'advanced' tab of the player identified by the given index."
    },
    "create_playerlist_text": {
        "prefix": "secret.create_playerlist_text",
        "body": "secret.create_playerlist_text(\"${1:text}\", ${2:entity index})",
        "description": "Creates a text UI element in the 'advanced' tab of the player identified by the given index."
    },
    "ui.create_groupbox": {
        "prefix": "secret.ui.create_groupbox",
        "body": "secret.ui.create_groupbox(\"${1:tab}\", \"${2|left,right|}\", \"${3:name}\", ${4:height})",
        "description": "Creates a groupbox within the specified tab of the menu."
    },
    "ui.create_checkbox": {
        "prefix": "secret.ui.create_checkbox",
        "body": "secret.ui.create_checkbox(\"${1:tab}\", \"${2:groupbox}\", \"${3:name}\", \"${4:config_name}\")",
        "description": "Creates a checkbox UI element within the specified tab and groupbox of the menu."
    },
    "ui.create_button": {
        "prefix": "secret.ui.create_button",
        "body": "secret.ui.create_button(\"${1:tab}\", \"${2:groupbox}\", \"${3:name}\", ${4:callback})",
        "description": "Creates a button UI element within the specified tab and groupbox of the menu. When the button is clicked, the specified callback function is invoked."
    },
    "ui.create_slider": {
        "prefix": "secret.ui.create_slider",
        "body": "secret.ui.create_slider(\"${1:tab}\", \"${2:groupbox}\", \"${3:name}\", ${4:min}, ${5:max}, \"${6:config_name}\")",
        "description": "Creates a slider UI element within the specified tab and groupbox of the menu."
    },
    "ui.create_colorpicker": {
        "prefix": "secret.ui.create_colorpicker",
        "body": "secret.ui.create_colorpicker(\"${1:tab}\", \"${2:groupbox}\", \"${3:name}\", \"${4:config_name}\")",
        "description": "Creates a colorpicker UI element within the specified tab and groupbox of the menu."
    },
    "ui.create_inputbox": {
        "prefix": "secret.ui.create_inputbox",
        "body": "secret.ui.create_inputbox(\"${1:tab}\", \"${2:groupbox}\", \"${3:name}\", \"${4:config_name}\")",
        "description": "Creates an input box UI element within the specified tab and groupbox of the menu."
    },
    "ui.create_hotkey": {
        "prefix": "secret.ui.create_hotkey",
        "body": "secret.ui.create_hotkey(\"${1:tab}\", \"${2:groupbox}\", \"${3:name}\", \"${4:config_name}\", \"${5:hotkey_display}\")",
        "description": "Creates a hotkey UI element within the specified tab and groupbox of the menu."
    },
    "ui.create_dropdown": {
        "prefix": "secret.ui.create_dropdown",
        "body": "secret.ui.create_dropdown(\"${1:tab}\", \"${2:groupbox}\", \"${3:name}\", \"${4:config_name}\", {\"${5:Item1}\", \"${6:Item2}\", \"${7:youcancreatemore}\"})",
        "description": "Creates a dropdown UI element within the specified tab and groupbox of the menu."
    },
    "ui.clear_elements": {
        "prefix": "secret.ui.clear_elements",
        "body": "secret.ui.clear_elements()",
        "description": "Clears all the current elements made with lua, such as secret.ui.create_checkbox, etc."
    },
    "ui.notify": {
        "prefix": "secret.ui.notify",
        "body": "secret.ui.notify(\"${1:text}\", ${2|0,1,2|})",
        "description": "Creates a new notification at the top left corner of the screen with the specified text and notif type."
    },
    "ui.menu_open": {
        "prefix": "secret.ui.menu_open",
        "body": "secret.ui.menu_open()",
        "description": "Whether the menu is currently open and returns a boolean value indicating its status."
    },
    "ui.console_open": {
        "prefix": "secret.ui.console_open",
        "body": "secret.ui.console_open()",
        "description": "Checks whether the console is currently open and returns a boolean value indicating its status."
    },
/*
       ____             __ _       
      / ___|___  _ __  / _(_) __ _ 
     | |   / _ \| '_ \| |_| |/ _` |
     | |__| (_) | | | |  _| | (_| |
      \____\___/|_| |_|_| |_|\__, |
                             |___/ 
*/
    "config.get": {
        "prefix": "secret.config.get",
        "body": "secret.config.get(\"${1:key}\")",
        "description": "Retrieves the current value of a configuration parameter identified by the specified key."
    },
    "config.set": {
        "prefix": "secret.config.set",
        "body": "secret.config.set(\"${1:key}\", ${2:value})",
        "description": "Sets a configuration value identified by the specified key to the desired value."
    },
/*
      ____  _                       _ _     _   
     |  _ \| | __ _ _   _  ___ _ __| (_)___| |_ 
     | |_) | |/ _` | | | |/ _ \ '__| | / __| __|
     |  __/| | (_| | |_| |  __/ |  | | \__ \ |_ 
     |_|   |_|\__,_|\__, |\___|_|  |_|_|___/\__|
                    |___/                       
*/
    "playerlist.add_friend": {
        "prefix": "secret.playerlist.add_friend",
        "body": "secret.playerlist.add_friend(${1:steamid64})",
        "description": "Adds a specified SteamID64 (string) to the friend list."
    },
    "playerlist.remove_friend": {
        "prefix": "secret.playerlist.remove_friend",
        "body": "secret.playerlist.remove_friend(${1:steamid64})",
        "description": "Removes a specified SteamID64 (string) from the friend list."
    },
    "playerlist.is_friend": {
        "prefix": "secret.playerlist.is_friend",
        "body": "secret.playerlist.is_friend(${1:steamid64})",
        "description": "Checks if the specified SteamID64 (string) is in the friend list and returns 'true' if the player is a friend, otherwise 'false'."
    },
    "playerlist.add_priority": {
        "prefix": "secret.playerlist.add_priority",
        "body": "secret.playerlist.add_priority(${1:steamid64})",
        "description": "Adds a specified SteamID64 (string) to the priority list."
    },
    "playerlist.remove_priority": {
        "prefix": "secret.playerlist.remove_priority",
        "body": "secret.playerlist.remove_priority(${1:steamid64})",
        "description": "Removes a specified SteamID64 (string) from the priority list."
    },
    "playerlist.is_priority": {
        "prefix": "secret.playerlist.is_priority",
        "body": "secret.playerlist.is_priority(${1:steamid64})",
        "description": "Checks if the specified SteamID64 (string) is in the priority list and returns 'true' if the player is a priority, otherwise 'false'."
    },
/*
      _     _     _                       
     | |   (_)___| |_ ___ _ __   ___ _ __ 
     | |   | / __| __/ _ \ '_ \ / _ \ '__|
     | |___| \__ \ ||  __/ | | |  __/ |   
     |_____|_|___/\__\___|_| |_|\___|_|   
                                          
*/
    "listener.add": {
        "prefix": "secret.listener.add",
        "body": "secret.listener.add(\"${1|view_render_post,think,paint_traverse,should_aimbot_target,should_draw_player,should_draw_entity|}\", \"${2:handler_name}\", function(${3:args})\n\t${4:}\nend)",
        "description": "Adds an listener for the specified event and handler name."
    },
    "view_render_post": { // comment this all out if you dont want it
        "prefix": "view_render_post",
        "body": "secret.listener.add(\"view_render_post\", \"${1:handler_name}\", function(${2:args})\n\t${3:}\nend)",
        "description": "Adds a listener for the 'view_render_post' event."
    },
    "think": {
        "prefix": "think",
        "body": "secret.listener.add(\"think\", \"${1:handler_name}\", function(${2:args})\n\t${3:}\nend)",
        "description": "Adds a listener for the 'think' event."
    },
    "paint_traverse": {
        "prefix": "paint_traverse",
        "body": "secret.listener.add(\"paint_traverse\", \"${1:handler_name}\", function(${2:args})\n\t${3:}\nend)",
        "description": "Adds a listener for the 'paint_traverse' event."
    },
    "should_aimbot_target": {
        "prefix": "should_aimbot_target",
        "body": "secret.listener.add(\"should_aimbot_target\", \"${1:handler_name}\", function(${2:args})\n\t${3:}\nend)",
        "description": "Adds a listener for the 'should_aimbot_target' event."
    },
    "should_draw_player": {
        "prefix": "should_draw_player",
        "body": "secret.listener.add(\"should_draw_player\", \"${1:handler_name}\", function(${2:args})\n\t${3:}\nend)",
        "description": "Adds a listener for the 'should_draw_player' event."
    },
    "should_draw_entity": {
        "prefix": "should_draw_entity",
        "body": "secret.listener.add(\"should_draw_entity\", \"${1:handler_name}\", function(${2:args})\n\t${3:}\nend)",
        "description": "Adds a listener for the 'should_draw_entity' event."
    },
/*
      ____  _                       
     / ___|| |_ ___  __ _ _ __ ___  
     \___ \| __/ _ \/ _` | '_ ` _ \ 
      ___) | ||  __/ (_| | | | | | |
     |____/ \__\___|\__,_|_| |_| |_|
                                    
*/
    "steam.invite_friend": {
        "prefix": "secret.steam.invite_friend",
        "body": "secret.steam.invite_friend(\"${1:steamid64}\")",
        "description": "Sends a game invite to the specified SteamID64."
    },
    "steam.set_name": {
        "prefix": "secret.steam.set_name",
        "body": "secret.steam.set_name(\"${1:name}\")",
        "description": "Allows you to set your real steam name to a specified name."
    },
    "steam.award_achievement": {
        "prefix": "secret.steam.award_achievement",
        "body": "secret.steam.award_achievement(${1:achievement_id})",
        "description": "Awards the specified achievement id."
    },
/*
      _   _      _   
     | \ | | ___| |_ 
     |  \| |/ _ \ __|
     | |\  |  __/ |_ 
     |_| \_|\___|\__|
                     
*/
    "net.setcvar": {
        "prefix": "secret.net.setcvar",
        "body": "secret.net.setcvar(\"${1:cvar}\", \"${2:value}\")",
        "description": "Call this with the name of the cvar (as a string) and the desired value (also as a string) to set the network variable to the specified value."
    },
    "net.disconnect": {
        "prefix": "secret.net.disconnect",
        "body": "secret.net.disconnect(\"${1:reason}\")",
        "description": "Allows you to disconnect from a server with a custom disconnect reason."
    },
    "net.stringcmd": {
        "prefix": "secret.net.stringcmd",
        "body": "secret.net.stringcmd(\"${1:cmd}\")",
        "description": "Allows to send a string command from the client to the server."
    },
    "net.block": {
        "prefix": "secret.net.block",
        "body": "secret.net.block(\"${1:string}\", ${2|true,false|})",
        "description": "Block a net message from being sent."
    },
    "net.unblock": {
        "prefix": "secret.net.unblock",
        "body": "secret.net.unblock(\"${1:string}\", ${2|true,false|})",
        "description": "Unblock a blocked net message."
    },
/*
      ____       _   _      __ _           _           
     |  _ \ __ _| |_| |__  / _(_)_ __   __| | ___ _ __ 
     | |_) / _` | __| '_ \| |_| | '_ \ / _` |/ _ \ '__|
     |  __/ (_| | |_| | | |  _| | | | | (_| |  __/ |   
     |_|   \__,_|\__|_| |_|_| |_|_| |_|\__,_|\___|_|   
                                                       
*/
    "pathfinder.destination": {
        "prefix": "secret.pathfinder.destination",
        "body": "secret.pathfinder.destination(${1:x}, ${2:y}, ${3:z})",
        "description": "Sets the destination for the pathfinder."
    },
    "pathfinder.recalc": {
        "prefix": "secret.pathfinder.recalc",
        "body": "secret.pathfinder.recalc()",
        "description": "Force the pathfinder to recalculate the path."
    },
    "pathfinder.get_nodes": {
        "prefix": "secret.pathfinder.get_nodes",
        "body": "secret.pathfinder.get_nodes()",
        "description": "Retrieves all the node positions in a table, in the pathfinder system."
    },
    "pathfinder.remove_nodes": {
        "prefix": "secret.pathfinder.remove_nodes",
        "body": "secret.pathfinder.remove_nodes(${1:x}, ${2:y}, ${3:z}, ${4:radius})",
        "description": "Removes nodes within a specified radius of a given position."
    },
    "pathfinder.get_path": {
        "prefix": "secret.pathfinder.get_path",
        "body": "secret.pathfinder.get_path()",
        "description": "Retrieves the generated path (waypoints) for the pathfinder in a table."
    },
    "pathfinder.set_path": {
        "prefix": "secret.pathfinder.set_path",
        "body": "secret.pathfinder.set_path(${1:path_table})",
        "description": "Sets the path for the pathfinder by providing a table of waypoints."
    },
/*
       ____                      _      
      / ___|___  _ __  ___  ___ | | ___ 
     | |   / _ \| '_ \/ __|/ _ \| |/ _ \
     | |__| (_) | | | \__ \ (_) | |  __/
      \____\___/|_| |_|___/\___/|_|\___|
                                        
*/
    "console.log": {
        "prefix": "secret.console.log",
        "body": "secret.console.log(\"${1:text}\", ${2|1,2,3,4|}, ${3|true,false|})",
        "description": "Logs a message onto a custom console with the specified text and log type and date."
    },
    "console.add_command": {
        "prefix": "secret.add_command",
        "body": "secret.add_command(\"${1:name}\", \"${2:description}\", function(${3:args}) \n\nend)",
        "description": "Creates a custom console command with the specified name and description."
    },
    "console.remove_command": {
        "prefix": "secret.remove_command",
        "body": "secret.remove_command(\"${1:name}\")",
        "description": "Removes an existing custom console command with the specified name"
    },
    "console.get_command_list": {
        "prefix": "secret.get_command_list",
        "body": "secret.get_command_list()",
        "description": "Retrieves a list of available commands."
    },
    "console.execute_command": {
        "prefix": "secret.console.execute_command",
        "body": "secret.console.execute_command(\"${1:name}\", ${2:args})",
        "description": "Executes a command with the specified name and optional arguments."
    },
/*
      __  __ _          
     |  \/  (_)___  ___ 
     | |\/| | / __|/ __|
     | |  | | \__ \ (__ 
     |_|  |_|_|___/\___|
                        
*/
    "misc.get_username": {
        "prefix": "secret.misc.get_username",
        "body": "secret.misc.get_username()",
        "description": "Retrieves the current username in the cheat."
    },
    "misc.in_screenshot": {
        "prefix": "secret.misc.in_screenshot",
        "body": "secret.misc.in_screenshot()",
        "description": "Returns true if a screenshot is being captured, otherwise false."
    },
    "misc.get_freecam_pos": {
        "prefix": "secret.misc.get_freecam_pos",
        "body": "secret.misc.get_freecam_pos()",
        "description": "Retrieves the current position of the freecam in the world."
    },
    "misc.get_freecam_angles": {
        "prefix": "secret.misc.get_freecam_angles",
        "body": "secret.misc.get_freecam_angles()",
        "description": "Retrieves the current angles of the freecam."
    },
    "misc.mouse_event": {
        "prefix": "secret.misc.mouse_event",
        "body": "secret.misc.mouse_event(${1:dwFlags}, ${2:dx}, ${3:dy}, ${4:dwData})",
        "description": "Simulates a mouse event by specifying various parameters such as flags, delta x, delta y, and data."
    },
    "misc.keybd_event": {
        "prefix": "secret.misc.keybd_event",
        "body": "secret.misc.keybd_event(${1:bVk}, ${2:bScan}, ${3:dwFlags}, ${4:dwExtraInfo})",
        "description": "Synthesizes a keystroke. It generates a keystroke down message, a keystroke up message, or a system keystroke."
    },
    "misc.add_to_player_esp": {
        "prefix": "secret.misc.add_to_player_esp",
        "body": "secret.misc.add_to_player_esp(${1:index}, \"${2:text}\", {${3:255, 255, 255, 255}}, ${4|1,2,3|})",
    //		"body": "local DRAW_TOP = 0\nlocal DRAW_BOTTOM = 1\nlocal DRAW_RIGHT = 2\nlocal DRAW_LEFT = 3\nsecret.add_to_esp(${1:index}, \"${2:text}\", {${3:255, 255, 255, 255}}, ${4|DRAW_TOP, DRAW_BOTTOM,DRAW_RIGHT,DRAW_LEFT|})",
        "description": "Add an ESP element for a specific player in the game. It allows you to display additional information about the player such as armor, etc."
    },
    "misc.add_to_ent_esp": {
        "prefix": "secret.misc.add_to_ent_esp",
        "body": "secret.misc.add_to_ent_esp(${1:index}, \"${2:text}\", {${3:255, 255, 255, 255}}, ${4|1,2,3|})",
    //		"body": "local DRAW_TOP = 0\nlocal DRAW_BOTTOM = 1\nlocal DRAW_RIGHT = 2\nlocal DRAW_LEFT = 3\nsecret.add_to_esp(${1:index}, \"${2:text}\", {${3:255, 255, 255, 255}}, ${4|DRAW_TOP, DRAW_BOTTOM,DRAW_RIGHT,DRAW_LEFT|})",
        "description": "Add an ESP element for a specific player in the game. It allows you to display additional information about the entity. Note: this only works on scripted entities."
    },
    "misc.in_safe_render": {
        "prefix": "secret.misc.in_safe_render",
        "body": "secret.misc.in_safe_render()",
        "description": "Returns true / false if the current hook is in a 'safe' render state, being hidden from screengrabs and recordings. Note: this requires 'obs bypass' to be enabled for it to work."
    },
    "misc.get_aimbot_target": {
        "prefix": "secret.misc.get_aimbot_target",
        "body": "secret.misc.get_aimbot_target()",
        "description": "Returns the current aimbot target, if the target is not valid, it will return nil. Note: this specific lua function can be detected."
    },
}