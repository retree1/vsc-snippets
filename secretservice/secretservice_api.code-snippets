{
/*
      ___       _                _       _ _            
     |_ _|_ __ | |_ ___ _ __ ___| |_ ___| | | __ _ _ __ 
      | || '_ \| __/ _ \ '__/ __| __/ _ \ | |/ _` | '__|
      | || | | | ||  __/ |  \__ \ ||  __/ | | (_| | |   
     |___|_| |_|\__\___|_|  |___/\__\___|_|_|\__,_|_|   
                                                        
*/
    "L.api": {
        "prefix": "L.api",
        "body": "L.api()",
        "description": "Pushes the API onto the stack for access",
    },
    "L.call": {
        "prefix": "L.call",
        "body": "L.call(${1:input:number},${2:output:number})",
        "description": "Calls a function thats pushed onto the stack, (ben add more info)",
    },
    "L.pop": {
        "prefix": "L.pop",
        "body": "L.pop(${1:number})",
        "description": "Pops a value off of the stack at the top",
    },
    "L.remove": {
        "prefix": "L.remove",
        "body": "L.remove(${1:index:number})",
        "description": "Removes a value at an index off of the stack",
    },
    "L.length": {
        "prefix": "L.length",
        "body": "L.length(${1:index:number})",
        "description": "Get the length of a value",
    },
    "L.next": {
        "prefix": "L.next",
        "body": "L.next(${1:index:number})",
        "description": "A pair-style iterator function for going through table, used like pairs",
    },
    "L.pushtransfer": {
        "prefix": "L.pushtransfer",
        "body": "L.pushtransfer(${1:value})",
        "description": "Transfers any datatype from your environment to the stack, environment to stack",
    },
    "L.gettransfer": {
        "prefix": "L.gettransfer",
        "body": "L.gettransfer(${1:index:number})",
        "description": "Transfers any datatype from the stack to your environment, stack to environment",
    },
    "L.gettop": {
        "prefix": "L.gettop",
        "body": "L.gettop()",
        "description": "Gets the current size of the Lua stack",
    },
    "L.gettype": {
        "prefix": "L.gettype",
        "body": "L.gettype(${1:index:number})",
        "description": "Gets the type ID of a given value",
    },
    "L.gettypename": {
        "prefix": "L.gettypename",
        "body": "L.gettypename(${1:index:number})",
        "description": "Gets the typename of a given value",
    },
    "L.newtable": {
        "prefix": "L.newtable",
        "body": "L.newtable()",
        "description": "Generates a blank table and pushes it onto the stack",
    },
    "L.newref": {
        "prefix": "L.newref",
        "body": "L.newref(${1:index:number})",
        "description": "Creates a reference link to a value, immune to the garbage collector",
    },
    "L.pushref": {
        "prefix": "L.pushref",
        "body": "L.pushref(${1:reference})",
        "description": "Pushes the referenced value back onto the stack",
    },
    "L.rmref": {
        "prefix": "L.rmref",
        "body": "L.rmref(${1:reference})",
        "description": "Removes the referenced value from registry",
    },
    "L.getupvalue": {
        "prefix": "L.getupvalue",
        "body": "L.getupvalue(${1:index:number}, ${2:id:number})",
        "description": "Gets the \"upvalue\" of a function at the top of the stack",
    },
    "L.setupvalue": {
        "prefix": "L.setgupvalue",
        "body": "L.setupvalue(${1:index:number}, ${2:id:number})",
        "description": "Sets the \"upvalue\" of a function at the top of the stack",
    },
    "L.getfenv": {
        "prefix": "L.getfenv",
        "body": "L.getfenv(${1:index:number})",
        "description": "Grabs the ENV and pushes it onto the stack, can use this to manipulate the environment",
    },
    "L.setfenv": {
        "prefix": "L.setfenv",
        "body": "L.setfenv(${1:index:number})",
        "description": "Sets the ENV of a functions at the index, consumes the table at the top of the stack, can use this to manipulate the environment",
    },
    "L.getmetatable": {
        "prefix": "L.getmetatable",
        "body": "L.getmetatable(${1:index:number})",
        "description": "Grabs the metatable of a table or userdata, and pushes it onto the stack",
    },
    "L.setmetatable": {
        "prefix": "L.setmetatable",
        "body": "L.setmetatable(${1:index:number})",
        "description": "Sets the metatable of a table or userdata at the index, consumes the table at the top of the stack",
    },
    "L.getfield": {
        "prefix": "L.getfield",
        "body": "L.getfield(${1:index:number}, \"${2:key:string}\")",
        "description": "Gets the value from a table and pushes it onto the stack",
    },
    "L.setfield": {
        "prefix": "L.setfield",
        "body": "L.setfield(${1:index:number}, \"${2:key:string}\")",
        "description": "Sets a value in a table by key, index corresponds to where the table is on the stack",
    },
    "L.gettable": {
        "prefix": "L.gettable",
        "body": "L.gettable(${1:index:number})",
        "description": "Gets the value from a table and pushes it onto the stack",
    },
    "L.settable": {
        "prefix": "L.settable",
        "body": "L.settable(${1:index:number})",
        "description": "Sets a value in a table by the key at the top of the stack",
    },
    "L.rawget": {
        "prefix": "L.rawget",
        "body": "L.rawget(${1:index:number})",
        "description": "Gets the value from a table and pushes it onto the stack",
    },
    "L.rawset": {
        "prefix": "L.rawset",
        "body": "L.rawset(${1:index:number})",
        "description": "Sets a value in a table by the key at the top of the stack, the top of the stack is the key, and top-1 is the value, unlike settable this will not invoke metatable callbacks",
    },
    "L.getboolean": {
        "prefix": "L.getboolean",
        "body": "L.getboolean(${1:index:number})",
        "description": "Attempts to get a boolean value from the Lua stack",
    },
    "L.getnumber": {
        "prefix": "L.getnumber",
        "body": "L.getnumber(${1:index:number})",
        "description": "Attempts to get a number value from the Lua stack",
    },
    "L.getstring": {
        "prefix": "L.getstring",
        "body": "L.getstring(${1:index:number})",
        "description": "Attempts to get a string value from the Lua stack",
    },
    "L.pushnil": {
        "prefix": "L.pushnil",
        "body": "L.pushnil()",
        "description": "Pushes a nil value onto the stack",
    },
    "L.pushnumber": {
        "prefix": "L.pushnumber",
        "body": "L.pushnumber(${1:number})",
        "description": "Pushes a number onto the stack",
    },
    "L.pushstring": {
        "prefix": "L.pushstring",
        "body": "L.pushstring(\"${1:string}\")",
        "description": "Pushes a string onto the stack",
    },
    "L.pushvalue": {
        "prefix": "L.pushvalue",
        "body": "L.pushvalue(${1:index:number})",
        "description": "Makes a copy of a value at the index and pushes it to the top of the stack",
    },
    "L.pushboolean": {
        "prefix": "L.pushboolean",
        "body": "L.pushboolean(${1:boolean})",
        "description": "Pushes a boolean onto the stack",
    },
    "L.isboolean": {
        "prefix": "L.isboolean",
        "body": "L.isboolean(${1:index:number})",
    },
    "L.iscfunction": {
        "prefix": "L.iscfunction",
        "body": "L.iscfunction(${1:index:number})",
    },
    "L.isfunction": {
        "prefix": "L.isfunction",
        "body": "L.isfunction(${1:index:number})",
    },
    "L.islightuserdata": {
        "prefix": "L.islightuserdata",
        "body": "L.islightuserdata(${1:index:number})",
    },
    "L.isnil": {
        "prefix": "L.isnil",
        "body": "L.isnil(${1:index:number})",
    },
    "L.isnumber": {
        "prefix": "L.isnumber",
        "body": "L.isnumber(${1:index:number})",
    },
    "L.isstring": {
        "prefix": "L.isstring",
        "body": "L.isstring(${1:index:number})",
    },
    "L.istable": {
        "prefix": "L.istable",
        "body": "L.istable(${1:index:number})",
    },
    "L.isthread": {
        "prefix": "L.isthread",
        "body": "L.isthread(${1:index:number})",
    },
    "L.isuserdata": {
        "prefix": "L.isuserdata",
        "body": "L.isuserdata(${1:index:number})",
    },
    "L.istype": {
        "prefix": "L.istype",
        "body": "L.istype(${1:index:number})",
    },
    "debug.detour": {
        "prefix": "debug.detour",
        "body": "debug.detour(${1:target}, ${2:detour})",
        "description": "Creates a memory-based hook towards a target lua function or C function",
    },
    "debug.isdetour": {
        "prefix": "debug.isdetour",
        "body": "debug.isdetour(${1:target})",
    },
    "debug.original": {
        "prefix": "debug.original",
        "body": "debug.original(${1:target})",
        "description": "If a function has a memory-mapping, this will return the original",
    },
    "debug.restore": {
        "prefix": "debug.restore",
        "body": "debug.restore(${1:target})",
        "description": "Restores the memory-mapped function",
    },
    "debug.clone": {
        "prefix": "debug.clone",
        "body": "debug.clone(${1:value})",
        "description": "Copys a value in memory, creating a completely new value but with the same characteristics",
    },
    "debug.replace": {
        "prefix": "debug.replace",
        "body": "debug.replace(${1:value}, ${2:value})",
        "description": "Replaces a value by reference in memory, effectively replacing all occurences of it.",
    },
    "debug.newcclosure": {
        "prefix": "debug.newcclosure",
        "body": "debug.newcclosure(${1:function})",
        "description": "Creates a new cfunction closure which is untraceable",
    },
    "debug.getgc": {
        "prefix": "debug.getgc",
        "body": "debug.getgc()",
        "description": "Gets the garbage collector table",
    },
    "debug.topointer": {
        "prefix": "debug.topointer",
        "body": "debug.topointer(${1:data}, ${2:str:boolean})",
        "description": "Converts a datatype into it's absolute pointer location",
    },
    "debug.frompointer": {
        "prefix": "debug.frompointer",
        "body": "debug.frompointer(${1:ptr:number})",
        "description": "Scans memory to find the pointer association",
    },
    "debug.setbuiltin": {
        "prefix": "debug.setbuiltin",
        "body": "debug.setbuiltin(${1:cfunction}, ${2:ffid:number})",
        "description": "Changes a cfunction to be a Fast Function with an ID, use newcclosure if you plan to make a detour with this",
    },
    "debug.getbuiltin": {
        "prefix": "debug.getbuiltin",
        "body": "debug.getbuiltin(${1:cfunction})",
        "description": "Gets the ffid number of a cfunction",
    },
    "debug.getupvalues": {
        "prefix": "debug.getupvalues",
        "body": "debug.getupvalues(${1:function})",
        "description": "Gets a list of upvalues and that a function has",
    },
    "debug.typestack": {
        "prefix": "debug.typestack",
        "body": "debug.typestack(${1:number})",
        "description": "Fetches a list of the current stack memory",
    },
    "debug.getstack": {
        "prefix": "debug.getstack",
        "body": "debug.getstack(${1:index:number})",
        "description": "Fetchs directly from the lua stack",
    },
    "debug.setstack": {
        "prefix": "debug.setstack",
        "body": "debug.setstack(${1:index:number}, ${2:data})",
        "description": "Sets a value at an index in stack memory, this is dangerous",
    },
    "fs.read": {
        "prefix": "fs.read",
        "body": "fs.read(\"${1:path}\")",
        "description": "Reads a file from a given path",
    },
    "fs.write": {
        "prefix": "fs.write",
        "body": "fs.write(\"${1:path}\", \"${2:data}\")",
        "description": "Writes to a file provided by the path",
    },
    "fs.isfile": {
        "prefix": "fs.isfile",
        "body": "fs.isfile(\"${1:path}\")",
        "description": "Checks if a filesystem object is a file",
    },
    "fs.isfolder": {
        "prefix": "fs.isfolder",
        "body": "fs.isfolder(\"${1:path}\")",
        "description": "Checks if a filesystem object is a folder",
    },
    "fs.listfiles": {
        "prefix": "fs.listfiles",
        "body": "fs.listfiles(\"${1:path}\")",
        "description": "Lists files in the specified path",
    },
    "fs.makefolder": {
        "prefix": "fs.makefolder",
        "body": "fs.makefolder(\"${1:path}\")",
        "description": "Creates a folder in the specified path",
    },
    "fs.delfolder": {
        "prefix": "fs.delfolder",
        "body": "fs.delfolder(\"${1:path}\")",
        "description": "Deletes a folder from the specified path",
    },
    "fs.delfile": {
        "prefix": "fs.delfile",
        "body": "fs.delfile(\"${1:path}\")",
        "description": "Deletes a file from the specified path",
    },
    "fs.append": {
        "prefix": "fs.append",
        "body": "fs.append(\"${1:path}\", \"${2:data}\")",
        "description": "Appends data onto the specified file",
    },
    "reflection.is": {
        "prefix": "reflection.is",
        "body": "reflection.is(\"${1:name}\")",
        "description": "Checks if the current execution is of a named",
    },
    "reflection.get": {
        "prefix": "reflection.get",
        "body": "reflection.get(\"${1:name}\")",
        "description": "Attempts to locate a lua_State",
    },
    "reflection.current": {
        "prefix": "reflection.current",
        "body": "reflection.current()",
        "description": "Gets the current lua_State this is executed in",
    },
    "reflection.all": {
        "prefix": "reflection.all",
        "body": "reflection.all()",
        "description": "Gets all instances of lua_State and their names",
    },
    "reflection.name": {
        "prefix": "reflection.name",
        "body": "reflection.name(${1:state})",
        "description": "Converts a lua_State to its named counterpart",
    },
    "reflection.execute": {
        "prefix": "reflection.execute",
        "body": "reflection.execute([[\n\t${1:source}\n]], \"${2:name}\", ${3:state})",
        "description": "Converts a lua_State to its named counterpart",
    },
    "reflection.compile": {
        "prefix": "reflection.compile",
        "body": "reflection.compile(\"${1:source}\", \"${2:name}\")",
        "description": "Compiles lua on the the current active state its in",
    },
    "reflection.replicate": {
        "prefix": "reflection.replicate",
        "body": "reflection.replicate(${1:function}, ${2:state})",
        "description": "Transfers a function to run on another lua_State, no upvalues must be present",
    },
    "reflection.open": {
        "prefix": "reflection.open",
        "body": "reflection.open(\"${1:name}\")",
        "description": "Spawns a new lua_State instance or returns one if it already exists",
    },
    "reflection.close": {
        "prefix": "reflection.close",
        "body": "reflection.close(${1:state})",
        "description": "Destroys a lua_State instance",
    },
    "reflection.stack": {
        "prefix": "reflection.stack",
        "body": "reflection.stack(${1:function(${2:lua_capi})}\n\nend, ${3:state})",
        "description": "Creates a temporary bridge between two lua states",
    },
	"signal.add": {
        "prefix": "signal.add",
        "body": "signal.add(\"${1:name}\", \"${2:indentity}\", function()\n\nend)",
        "description": "Adds a function to an signal, this will call the callback when C++ invokes it",
    },
	"signal.remove": {
        "prefix": "signal.remove",
        "body": "signal.remove(\"${1:name}\", \"${2:indentity}\")",
        "description": "Removes a function from a signal",
    },
	"signal.get": {
        "prefix": "signal.get",
        "body": "signal.get(\"${1:name}\", \"${2:indentity}\")",
        "description": "Attempts to retrieve a function from the signal callbacks",
    },
	"signal.call": {
        "prefix": "signal.call",
        "body": "signal.call(${1:state}, \"${2:name}\")",
        "description": "Calls events on a lua_State, Must have the same matching name",
    },
	"signal.connect": {
        "prefix": "signal.connect",
        "body": "signal.connect(\"${1:name}\", \"${2:identity}\" function()\n\nend)",
        "description": "Same as signal.add, RBLX standard",
    },
	"signal.disconnect": {
        "prefix": "signal.disconnect",
        "body": "signal.disconnect(\"${1:name}\", \"${2:identity}\")",
        "description": "Same as signal.remove, RBLX standard",
    },
	"signal.connection": {
        "prefix": "signal.connection",
        "body": "signal.connection(\"${1:name}\", \"${2:identity}\")",
        "description": "Same as signal.get, RBLX standard",
    },
	"signal.fire": {
        "prefix": "signal.fire",
        "body": "signal.fire(${1:state}, \"${2:name}\")",
        "description": "Same as signal.call, RBLX standard",
    },
    "iot.http": {
        "prefix": "iot.http",
        "body": "iot.http(\"${1:url}\", ${2:options}, function(${3:response}))\n\nend)", // i think the // is a error but whatever
        "description": "Makes an HTTP/HTTPS request to an address or domain",
    },
    "iot.socket": {
        "prefix": "iot.socket",
        "body": "iot.socket(\"${1:url}\", ${2:options})", // will need to add the options later to both iot
        "description": "Creates a socket object which is connected to an address or domain, the socket isn't activated until you invoke it to do so",
    },
    "paint.point.vector2": {
        "prefix": "paint.point.vector2",
        "body": "paint.point.vector2(${1:x}, ${2:y})",
        "description": "Creates a 2D vector for paint to recognize",
    },
    "paint.point.vector3": {
        "prefix": "paint.point.vector3", // add shortcuts to paint
        "body": "paint.point.vector3(${1:x}, ${2:y})",
        "description": "Creates a 3D vector for paint to recognize",
    },
    "paint.color.rgb": {
        "prefix": "paint.color.rgb",
        "body": "paint.color.rgb(${1:r}, ${2:g}, ${3:b})",
        "description": "Creates an RGB based color",
    },
    "paint.color.rgba": {
        "prefix": "paint.color.rgba",
        "body": "paint.color.rgba(${1:r}, ${2:g}, ${3:b}, ${4:a})",
        "description": "Creates an RGBA based color",
    },
    "paint.color.hex": {
        "prefix": "paint.color.hex",
        "body": "paint.color.hex(\"${1:hex code}\")",
        "description": "Creates an RGBA based color from hex",
    },
    "paint.color.hsv": {
        "prefix": "paint.color.hsv",
        "body": "paint.color.hsv(${1:h}, ${2:s}, ${3:v}, ${4:a})",
        "description": "Creates an RGBA based color from HSV",
    },
    "paint.color.hsl": {
        "prefix": "paint.color.hsl",
        "body": "paint.color.hsl(${1:h}, ${2:s}, ${3:L}, ${4:a})",
        "description": "Creates an RGBA based color from HSL",
    },
    // missing paint main functions as i am lazy will do later

/*
       ____                       _       __  __           _ 
      / ___| __ _ _ __ _ __ _   _( )___  |  \/  | ___   __| |
     | |  _ / _` | '__| '__| | | |// __| | |\/| |/ _ \ / _` |
     | |_| | (_| | |  | |  | |_| | \__ \ | |  | | (_) | (_| |
      \____|\__,_|_|  |_|   \__, | |___/ |_|  |_|\___/ \__,_|
                            |___/                            
*/










}